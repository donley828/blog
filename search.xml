<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>记一次 Cesium.js 相关性能优化</title>
    <url>/blog/2020/11/07/%E8%AE%B0%E4%B8%80%E6%AC%A1%20Cesium.js%20%E7%9B%B8%E5%85%B3%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>在公司项目的综合概览-电子地图模块，为了达到离线部署的目的，使用了 Cesium.js 做了地图渲染引擎。但是在开发结束之后发现地图渲染过程中有明显卡顿，尤其是四周的几个使用了 <transition> 的数据图框实际帧数不到10FPS，简直是肉眼可见的卡。</transition></p>
<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>首先使用 Chrome 的 devtools 进行了一下性能分析。如下图：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fed5ae17ca434924846d4df84dc65eef~tplv-k3u1fbpfcp-watermark.image" alt></p>
<p>这是这个地图模块从点击菜单路由开始到全部资源和动画加载执行完成的时间，抛开时间不说，几个动画执行时的 fps 只有不到10，简直就是几张ppt。而且大部分时间都消耗在了 JS 运行上。于是进一步查看 Call Tree，果不其然，那几个红标的长耗时基本上都是 Cesium.js 的渲染流程。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98d2d441af2447e688fe23c28e08d401~tplv-k3u1fbpfcp-watermark.image" alt></p>
<h3 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h3><p>因为 Cesium.js 是第三方库，所以直接分析代码的执行流程也是不可行的。这时候只能去 Google 碰碰运气，发现 Vue-数据劫持 这个名词出现频率比较高。其实数据劫持就是通过 Object.defineProperty 去劫持的对象的 setter 和 getter操作，比如在数据更新的时候同时更新 DOM。就是双向绑定的原理。</p>
<p>这个时候我再回去看了一眼代码。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0086ed223321460ab1dabb930dc7a063~tplv-k3u1fbpfcp-watermark.image" alt></p>
<p>果然把 viewer (Cesium.js 初始化的地图对象) 保存在了 Vue 实例上，而且在各种事件操作中大量调用。</p>
<p>后来只能把这个对象保存在 window 上，即使不是一个很优雅的办法。</p>
<h3 id="闹鬼了"><a href="#闹鬼了" class="headerlink" title="闹鬼了"></a>闹鬼了</h3><p>这一套操作结束之后，发现并没有什么卵用，虽然进入页面时间有所改善，但是那几个 <transition> 还是肉眼可见的卡，尤其是手动显示隐藏的操作基本上没有什么变化。</transition></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ec07128b8084b48bf8f42f873c09ba9~tplv-k3u1fbpfcp-watermark.image" alt></p>
<p>我只好针手动显示隐藏这个过程再进行一次分析，然后发现整个渲染时长基本没什么变化，还是很久，最长的依然是 JS 运行。再次查看 Call Tree 大部分时间都耗费在地图的 resize() 方法上。查看代码发现我只是控制了几个 div 的显示隐藏，为什么会出发地图的重新渲染呢。然后只能点点点，最后我的注意力落在了一个滚动条上面。</p>
<p>滚动条的出现改变了页面主体的宽度，容器宽度的变化导致 Cesium 出发 resize() 方法，长耗时的 JS 阻塞了动画的执行造成了卡顿。</p>
<p>机智的我赶紧给 div#app 添加了一行 overflow-x: hidden; 再刷新一遍，完美解决。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>整个分析过程也没持续多长时间，主要原因还是因为开发过程还是太相信 CPU 的执行效率和第三方库对性能处理。真的遇到性能问题的时候，大部分原因还是在业务代码的不合理上。而且作为前端，大部分代码还是运行在客户的机器上，还是要尽量的“向下兼容”。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Gis</tag>
        <tag>可视化</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>关于JS对象</title>
    <url>/blog/2020/03/24/%E5%85%B3%E4%BA%8EJS%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="关于-JS-对象"><a href="#关于-JS-对象" class="headerlink" title="关于 JS 对象"></a>关于 JS 对象</h1><p>JS 中的对象是一组无序的键值对</p>
<p>对象属性一般有两类属性，数据属性和访问器属性</p>
<p>数据属性包括四个特征：</p>
<ul>
<li>value：属性的值</li>
<li>writable：决定属性能否被修改</li>
<li>enumerable：决定 for in 能否枚举该属性</li>
<li>configurable：决定属性能否被删除或者修改其特征值</li>
</ul>
<p>访问器属性：</p>
<ul>
<li>getter：undefined或者函数，取属性值时调用</li>
<li>setter：undefined或者函数，设置属性值时调用</li>
<li>enumerable：决定 for in 能否枚举该属性</li>
<li>configurable：决定该属性能否被删除或者改变特征值</li>
</ul>
<p>这两种对象属性的特征值，可以通过 Object.getOwnPropertyDescriptor() 获得，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(o, <span class="string">'a'</span>) <span class="comment">// &#123;value: 1, writable: true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure>
<p>ES5 的 Object.defineProperty 方法可以定义这些特征值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">'a'</span>, &#123;</span><br><span class="line">  value: <span class="number">5</span>,</span><br><span class="line">  ···</span><br><span class="line">&#125;)</span><br><span class="line">o.a <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<h2 id="对象的原型"><a href="#对象的原型" class="headerlink" title="对象的原型"></a>对象的原型</h2><p>原型在 JS 中就是一个对象，我们创建的每一个对象都有私有字段 [[prototype]]，就是对象的原型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;</span><br><span class="line">o.__proto__</span><br></pre></td></tr></table></figure>
<p>在读取一个对象的属性时，如果当前对象没有此属性，会继续访问对象的原型，直到原型为空或者找到为止。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端，JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Koa@2 中间件加载机制解析</title>
    <url>/blog/2018/08/30/Koa-2-%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>Koa 是 tj 主导的一个相比于 Express 很小的 Nodejs Web 框架。它支持大部分 es7 的语法比如 async，await 函数。<br>提供了主要为<code>use()</code>的函数库，通过自己编写中间件实现一个健壮的 web 应用。</p>
<a id="more"></a>
<h2 id="与-Exprees-对比"><a href="#与-Exprees-对比" class="headerlink" title="与 Exprees 对比"></a>与 Exprees 对比</h2><p>本文主要探究它的中间件加载机制，所以主要讨论中间件的内容。</p>
<h3 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h3><p>就拿 Express 来说，它是类似这样的：</p>
<blockquote>
<p>Request -&gt; middleware1 -&gt;…-&gt; middleware2 -&gt; Response</p>
</blockquote>
<p>而且在中间件执行过程中，如果没有终结或者说返回 <code>Response</code>时，就必须调用<code>next()</code>方法直到请求处理结束，否则这个请求会被挂起。</p>
<h3 id="Koa"><a href="#Koa" class="headerlink" title="Koa"></a>Koa</h3><p>关于 Koa 中间件的执行过程，就譬如下面这一段代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">···</span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;);</span><br><span class="line">···</span><br></pre></td></tr></table></figure>
<p>假如这是应用注册的两个中间件，请求的时候这段代码的输出结果将会是<br>1，2，3，4<br>为什么呢？<br>因为当 Koa 的中间件在遇到<code>await next()</code>的时候就会跳过其后的代码去执行下一个中间件的代码，依次一直到有了请求返回也就是中间件执行到最后一个的时候就会按照倒序返回执行<code>await next()</code>之后的代码。这样说可能不好理解。网上有一张洋葱圈模型可以很好的解释这个流程。<br><img src="http://ojxko64c5.bkt.clouddn.com/%E6%B4%8B%E8%91%B1%E5%9C%88%E6%A8%A1%E5%9E%8B-koajs.png" alt></p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>有了这个机制，我们可以很方便的封装一些 cookie 处理、服务响应时间等有用的中间件。<br>但是带来便利的同时为什么可以完美的按照这个顺序执行呢？带着疑问我打开了 koajs 的源码。<br>（不得不说 tj 大神写的代码真是既优雅又实用）</p>
<h3 id="中间件流程"><a href="#中间件流程" class="headerlink" title="中间件流程"></a>中间件流程</h3><p> 大概说一下，koa 内部声明了一个叫<code>middleware</code>的空数组，每次执行<code>app.use</code>的时候，都会有一个<code>push</code>方法把中间件的函数存进去。<br>接着我们可以在<code>/lib/application.js</code>的 127 行左右找到关于<code>middleware</code>的处理，原来是传入了一个叫<code>compose</code>的方法内。</p>
<h3 id="koa-compose"><a href="#koa-compose" class="headerlink" title="koa-compose"></a>koa-compose</h3><p>原来中间件的处理单独放在了一个 repo 里，找到之后只有一个<code>index.js</code>文件。<br>打开如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">middleware</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(middleware))</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Middleware stack must be an array!"</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> fn <span class="keyword">of</span> middleware) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">"function"</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Middleware must be composed of functions!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> <span class="variable">context</span></span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return <span class="type">&#123;Promise&#125;</span></span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@api <span class="variable">public</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个dispatch函数,dispatch会返回内部 Promosie.resolve，可以通过.then方法接收</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">context, next</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// last called middleware #</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="number">0</span>); <span class="comment">// 0为第一个中间件</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (i &lt;= index)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"next() called multiple times"</span>));</span><br><span class="line">      index = i;</span><br><span class="line">      <span class="keyword">let</span> fn = middleware[i];</span><br><span class="line">      <span class="keyword">if</span> (i === middleware.length) fn = next;</span><br><span class="line">      <span class="keyword">if</span> (!fn) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 递归执行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(fn(context, dispatch.bind(<span class="literal">null</span>, i + <span class="number">1</span>)));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="简化"><a href="#简化" class="headerlink" title="简化"></a>简化</h3><p>可能大部人看到这里还是不明白为什么会按照“洋葱”的顺序执行。<br>我们可以把这幅代码简化一下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">middleware</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">context, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">      index = i;</span><br><span class="line">      <span class="keyword">let</span> fn = middleware[i];</span><br><span class="line">      <span class="keyword">if</span> (i === middleware.length) &#123;</span><br><span class="line">        fn = next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!fn) <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">return</span> fn(context, <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dispatch(i + <span class="number">1</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ms = [</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"1"</span>);</span><br><span class="line">    next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"3"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"2"</span>);</span><br><span class="line">    next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"3"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line">compose(ms)();</span><br></pre></td></tr></table></figure>
<p>我们会惊奇的发现这段代码的执行结果竟然和 koajs 的中间件顺序一模一样。<br>观察发现我们是把 <code>Promise</code> 对象相关的内容去掉，换为原始的回调函数实现。</p>
<p>So,这个时候我们回到了最最最初的起点就是回调函数与异步。对于中间件数组来说，从<code>index</code>=0 开始执行，当在某个中间件中执行<code>next()</code>的时候，其实就行在执行下一个中间件，依次一直执行到这个次序结束。那么在这个过程中<code>next()</code>之后的代码在 js 的事件机制来说就会被放入一个事件“队列”里。<br>然而，这个队列本质上是一个栈，遵循先进后出和后进先出的原则，所以到最后一个的时候又会按照逆序执行一遍。<br>这时候再回头去看之前的源码就会发现简单多了</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>总之还是感觉是对新特性的掌握度不够，同样的道理加一些干扰就会影响理解上的进度。<br>欢迎吐槽。</p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Nodejs</tag>
        <tag>Koa</tag>
      </tags>
  </entry>
  <entry>
    <title>ES API探底系列（一）：Array</title>
    <url>/blog/2018/05/23/ES%20API%E6%8E%A2%E5%BA%95%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AArray/</url>
    <content><![CDATA[<p>这段时间工作不太饱和，趁现在补补基础，写这个系列的目的只有一个就是复习。<br>毕竟写博客的过程在于纪录和成长，结果只是次要的。<br>不包含已经废弃掉的方法。<br><a id="more"></a></p>
<p>JS 中的数组是类似于列表的一种高阶对象</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="Array-length"><a href="#Array-length" class="headerlink" title="Array.length"></a>Array.length</h3><p>length 属性的值是一个 0 到 2^32-1 的整数。<br><code>length</code>是 Array 实例的一个属性，它可以被显式设置，如果设置超过数组长度的值，多出来的部分会被设置为<code>undefined</code>，如果设置为小于数组长度的值则数组会被截断。</p>
<h3 id="Array-prototype"><a href="#Array-prototype" class="headerlink" title="Array.prototype"></a>Array.prototype</h3><p>是<code>Array</code>构造函数的原型，通过给它设置方法或者属性可供所有数组使用。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray(<span class="built_in">Array</span>.prototype); </span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h3><p><code>Array.from(arrayLike[, mapFn[, thisArg]])</code>从一个类似数组或可迭代对象中创建一个新的数组。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(<span class="string">'foo'</span>));</span><br><span class="line"><span class="comment">// expected output: Array ["f", "o", "o"]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], x =&gt; x + x));</span><br><span class="line"><span class="comment">// expected output: Array [2, 4, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数组去重</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">combine</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">let</span> arr = [].concat.apply([], <span class="built_in">arguments</span>);  <span class="comment">//没有去重复的新数组 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr));</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> m = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>], n = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>]; </span><br><span class="line"><span class="built_in">console</span>.log(combine(m,n));                     <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray()"></a>Array.isArray()</h3><p><code>Array.isArray(obj)</code>确定传的值是不是一个 <code>Array</code>。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面的函数调用都返回 true</span></span><br><span class="line"><span class="built_in">Array</span>.isArray([]);</span><br><span class="line"><span class="built_in">Array</span>.isArray([<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="keyword">new</span> <span class="built_in">Array</span>());</span><br><span class="line"><span class="comment">// 鲜为人知的事实：其实 Array.prototype 也是一个数组。</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="built_in">Array</span>.prototype); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的函数调用都返回 false</span></span><br><span class="line"><span class="built_in">Array</span>.isArray();</span><br><span class="line"><span class="built_in">Array</span>.isArray(&#123;&#125;);</span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="literal">null</span>);</span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="literal">undefined</span>);</span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="number">17</span>);</span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="string">'Array'</span>);</span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="literal">true</span>);</span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">Array</span>.isArray(&#123; <span class="attr">__proto__</span>: <span class="built_in">Array</span>.prototype &#125;);</span><br></pre></td></tr></table></figure></p>
<p>尽量使用<code>isArray</code>而不是<code>instanceof</code>,前者可以检测 iframes。</p>
<h3 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h3><p><code>Array.of(num)</code> 返回一个长度为 num 的数组，是空位不是 undefined。</p>
<h3 id="Array-prototype-contact"><a href="#Array-prototype-contact" class="headerlink" title="Array.prototype.contact()"></a>Array.prototype.contact()</h3><p><code>contact(arr1,arr2..)</code>用于合并一个或多个数组。会返回一个新的数组。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array1 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">var</span> array2 = [<span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array1.concat(array2));</span><br><span class="line"><span class="comment">// expected output: Array ["a", "b", "c", "d", "e", "f"]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Array-prototype-copyWithin"><a href="#Array-prototype-copyWithin" class="headerlink" title="Array.prototype.copyWithin()"></a>Array.prototype.copyWithin()</h3><p><code>copyWithin(target, start, end)</code>浅复制数组的一部分到同一数组的另一个位置，并且返回，原数组会被修改，被移动的部分大小不会被改变。这个方法的三个参数都是整数。<br>如果<code>target</code>大于数组的<code>length</code>，不会被拷贝。如果<code>target</code>在<code>start</code>之后，将会被修改。<br>如果<code>start</code>或者<code>end</code>为负数，会从末尾开始计算。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// place at position 0 the element between position 3 and 4</span></span><br><span class="line"><span class="built_in">console</span>.log(array1.copyWithin(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line"><span class="comment">// expected output: Array [4, 2, 3, 4, 5]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">-2</span>, <span class="number">-3</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="comment">// [1, 2, 3, 3, 4]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Array-prototype-entries"><a href="#Array-prototype-entries" class="headerlink" title="Array.prototype.entries()"></a>Array.prototype.entries()</h3><p><code>entries()</code>返回一个新的<strong>Array Iterator</strong>对象，该对象包含调用这个方法的数组中每个索引的键值。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array1 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iterator1 = array1.entries();</span><br><span class="line"><span class="built_in">console</span>.log(iterator1.next().value);</span><br><span class="line"><span class="comment">// expected output: Array [0, "a"]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator1.next().value);</span><br><span class="line"><span class="comment">// expected output: Array [1, "b"]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Array-prototype-every"><a href="#Array-prototype-every" class="headerlink" title="Array.prototype.every()"></a>Array.prototype.every()</h3><p><code>every(callback, thisArg)</code>方法测试数组的所有元素是否都通过了指定函数的测试。<br>如果数组的所有元素都通过了<code>callback</code>，这个方法则返回<code>true</code>，反之则返回<code>false</code>。<br><code>callback</code>参数为测试函数，<code>thisArg</code>参数可以指定执行<code>callback</code>时<code>this</code>的值。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBigEnough</span>(<span class="params">element, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (element &gt;= <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> passed = [<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>].every(isBigEnough);</span><br><span class="line"><span class="comment">// passed is false</span></span><br><span class="line">passed = [<span class="number">12</span>, <span class="number">54</span>, <span class="number">18</span>, <span class="number">130</span>, <span class="number">44</span>].every(isBigEnough);</span><br><span class="line"><span class="comment">// passed is true</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Array-prototype-fill"><a href="#Array-prototype-fill" class="headerlink" title="Array.prototype.fill()"></a>Array.prototype.fill()</h3><p><code>fill(value, start, end)</code>用一个固定值填充数组的某一部分，不包括<code>end</code>索引。<br>参数<code>start</code>和<code>end</code>默认值分别为0和数组的<code>length</code>。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].fill(<span class="number">4</span>);               <span class="comment">// [4, 4, 4]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].fill(<span class="number">4</span>, <span class="number">1</span>);            <span class="comment">// [1, 4, 4]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].fill(<span class="number">4</span>, <span class="number">-3</span>, <span class="number">-2</span>);       <span class="comment">// [4, 2, 3]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Array-prototype-filter"><a href="#Array-prototype-filter" class="headerlink" title="Array.prototype.filter()"></a>Array.prototype.filter()</h3><p><code>filter(callback(element, index, array))[thisArg]</code>方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。<br><code>callback</code>参数是用来测试的函数。<code>element</code>当前正在处理的元素。<code>index</code>正在处理的元素的索引。<code>array</code>调用了filter的数组。<code>thisArg</code>执行<code>callback</code>时的用于this的值。</p>
<h3 id="Array-prototype-find"><a href="#Array-prototype-find" class="headerlink" title="Array.prototype.find()"></a>Array.prototype.find()</h3><h3 id="Array-prototype-findIndex"><a href="#Array-prototype-findIndex" class="headerlink" title="Array.prototype.findIndex()"></a>Array.prototype.findIndex()</h3><h3 id="🔍-Array-prototype-flat"><a href="#🔍-Array-prototype-flat" class="headerlink" title="🔍 Array.prototype.flat()"></a>🔍 Array.prototype.flat()</h3><h3 id="🔍-Array-prototype-flatMap"><a href="#🔍-Array-prototype-flatMap" class="headerlink" title="🔍 Array.prototype.flatMap()"></a>🔍 Array.prototype.flatMap()</h3><h3 id="Array-prototype-forEach"><a href="#Array-prototype-forEach" class="headerlink" title="Array.prototype.forEach()"></a>Array.prototype.forEach()</h3><h3 id="Array-prototype-includes"><a href="#Array-prototype-includes" class="headerlink" title="Array.prototype.includes()"></a>Array.prototype.includes()</h3><h3 id="Array-prototype-indexOf"><a href="#Array-prototype-indexOf" class="headerlink" title="Array.prototype.indexOf()"></a>Array.prototype.indexOf()</h3><h3 id="Array-prototype-join"><a href="#Array-prototype-join" class="headerlink" title="Array.prototype.join()"></a>Array.prototype.join()</h3><h3 id="Array-prototype-keys"><a href="#Array-prototype-keys" class="headerlink" title="Array.prototype.keys()"></a>Array.prototype.keys()</h3>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>MDN</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>快速上手--react</title>
    <url>/blog/2018/05/11/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-react/</url>
    <content><![CDATA[<h1 id="项目快速上手"><a href="#项目快速上手" class="headerlink" title="项目快速上手"></a>项目快速上手</h1><p> 作为一个实习生或者新人或者 ，第一次用 <strong>react</strong> 进行项目开发时，会遇到不同程度的困难，我在本文就 <code>丰农</code> 项目的心得结合一些 react 编程思想做一个小小的总结，以便于  学习或者利于后来新人快速上手。</p>
<a id="more"></a>
<p><br>主要从三个个方面展开：</p>
<ol>
<li> 数据驱动流思想</li>
<li>团队开发</li>
<li>React + Redux</li>
</ol>
<h2 id="1-数据驱动流思想"><a href="#1-数据驱动流思想" class="headerlink" title="1.数据驱动流思想"></a>1.数据驱动流思想</h2><blockquote>
<p> 如果之前有前端 <strong>MV*</strong> 框架项目开发经验，可以略过此节</p>
</blockquote>
<p>何为数据驱动流，个人觉得只有很好的理解了这个概念，才能才开发过程中得心应手。 假设数据（d 表示）与视图（V 表示）之间存在一种特殊关系，可以是这样：</p>
<p>$$V=f(d)$$</p>
<p>数据变化时时：</p>
<p>$$V + \Delta V =f(d+\Delta d)$$</p>
<p>相应的  视图也也发生了变化，$f$ 即为之间的映射关系。关于$\Delta d$,它是由某个操作引起的，可以把这个操作类比为 <code>reduce</code>, 每一次的状态变更综合起来就会渲染最后的视图。</p>
<p>所有我们的项目不管任何组件，我们需要维护的只是数据和如何操作数据。</p>
<h2 id="2-React-Redux"><a href="#2-React-Redux" class="headerlink" title="2.React + Redux"></a>2.React + Redux</h2><h3 id="React"><a href="#React" class="headerlink" title="React"></a>React</h3><h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><ul>
<li>无状态组件（Stateless Functional Component）<ul>
<li>1.不提供 state，refs，生命周期  等属性方法</li>
<li>2. 一般用作展示组件</li>
</ul>
</li>
<li>有状态组件（Component）<ul>
<li>1.<code>render()</code>函数中  尽量  只保留 return 语句和 this.props。</li>
</ul>
</li>
</ul>
<h4 id="开发-tips"><a href="#开发-tips" class="headerlink" title="开发 tips"></a>开发 tips</h4><ul>
<li> 对于公共函数封装，可先查看@utils 文件件，如果有使用即可，如果没有可对其补充，如果需要新建，在此之前需要思考可行性，斟酌代码量和可读性的基础上进行封装 📦。</li>
<li><p> 一般的项目目录（components,container,store 的文件夹名称一般是一一对应。）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">|-assets/   // 静态资源包  </span><br><span class="line">|-components/   // 视图组件</span><br><span class="line">|-container/    // 容器组件</span><br><span class="line">|-layouts/  // 页面结构组件</span><br><span class="line">|-store/    // redux</span><br><span class="line">|-utils/    //  工具函数包</span><br><span class="line">|-app.js    // 路由</span><br><span class="line">|-index.js  // 项目入口</span><br><span class="line">|-index.scss    // 全局样式</span><br><span class="line">|-theme.js  // antd 主题文件</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p><a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0" target="_blank" rel="noopener">展示和容器组件</a>由 react 开发者 <a href="https://github.com/gaearon" target="_blank" rel="noopener">dan</a>提出</p>
</blockquote>
<h3 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h3><p><a href="https://cn.redux.js.org/" target="_blank" rel="noopener">基本概念</a>，快速入门可以 <a href="https://github.com/berwin/Blog/issues/4" target="_blank" rel="noopener">参考这里</a><br><br> 例如丰农项目中使用了<code>react-redux</code>,需要理解  以下几个概念</p>
<ul>
<li>Provider 组件保存 store 给子组件中的 connect 使用</li>
<li>Connect 把 State 和 dispatch 转换成 props 传递给子组件。</li>
</ul>
<h4 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h4><ul>
<li>保持 fetch 参数的纯洁性，提升代码可读性</li>
<li>fetch 之后的相同操作可以进行处理 例如：loading 操作….</li>
</ul>
<h2 id="3-团队开发"><a href="#3-团队开发" class="headerlink" title="3.团队开发"></a>3.团队开发</h2><h3 id="代码风格"><a href="#代码风格" class="headerlink" title=" 代码风格"></a> 代码风格</h3><p>关于代码风格，已经有了很完善的 lint 工具，例如：ESlint。</p>
<p> 我想补充的就是如果你使用的  编辑器  是 VScode，可以在拓展市场寻找适合自己的格式化工具，比如 Prettier， 它在格式化的时候数据源是 .eslintrc。</p>
<h3 id="软技能"><a href="#软技能" class="headerlink" title="软技能"></a>软技能</h3><ol>
<li>沟通</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>项目</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>Redux学习总结</title>
    <url>/blog/2018/03/20/Redux%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>Redux 的学习心得，待修改</p>
<a id="more"></a>
<h2 id="1-Action"><a href="#1-Action" class="headerlink" title="1.Action"></a>1.Action</h2><p>Action 是一个 JS 对象，是对行为类型的一个描述或者是添加数据时的具体数据，或者删除数据是的数据项 id，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">···</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"type"</span>: <span class="string">"ADD_TODO"</span>,</span><br><span class="line">  <span class="string">"text"</span>: <span class="string">"Back School"</span></span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure>
<p>一般需要一个叫做 actionCreator 的函数创建 action。比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addItem</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: <span class="string">"ADD_TODO"</span>,</span><br><span class="line">    text: text</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-Reducer"><a href="#2-Reducer" class="headerlink" title="2.Reducer"></a>2.Reducer</h2><p>Reducer 就是根据 Action 的描述进行具体的数据操作，一般获得两个参数<code>State</code>和<code>Action</code>,一般根据 Type 的类型更新 State，一般不直接修改，而是返回新的 <code>State</code>。比如上面那条 Action:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">···</span><br><span class="line"><span class="keyword">case</span> ADD_TODO:</span><br><span class="line">      <span class="keyword">return</span> [</span><br><span class="line">        ...state,</span><br><span class="line">        &#123;</span><br><span class="line">          text: action.text,</span><br><span class="line">          completed: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">···</span><br></pre></td></tr></table></figure>
<h3 id="combineReducers"><a href="#combineReducers" class="headerlink" title="combineReducers"></a>combineReducers</h3><p>这个函数用来管理各个分离的小 Reducer</p>
<h2 id="3-Store"><a href="#3-Store" class="headerlink" title="3.Store"></a>3.Store</h2><p>Stroe 就是整个应用存放数据的地方，一个应用只有一个 store。</p>
<blockquote>
<ul>
<li>store 可以维持应用的 state</li>
<li>提供 <strong>getState()</strong> 方法获取 state</li>
<li>通过 <strong>dispatch(action)</strong> 更新 state</li>
<li>通过 <strong>subscribe(listener)</strong> 注册监听器</li>
<li><strong>replaceReducer</strong>用来替换 store 当前用来处理 state 的 reducer</li>
</ul>
</blockquote>
<h2 id="4-Redux-流程图"><a href="#4-Redux-流程图" class="headerlink" title="4.Redux 流程图"></a>4.Redux 流程图</h2><p><img src="https://camo.githubusercontent.com/76224d874f32535aa62c0cd01750fb71fb02cf53/687474703a2f2f70362e7168696d672e636f6d2f642f696e6e2f39613331326463632f7265647578466c6f772e706e67" alt="redux-process"></p>
<h2 id="5-react-redux"><a href="#5-react-redux" class="headerlink" title="5.react-redux"></a>5.react-redux</h2><h3 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h3><p>Provider 是一个 React 组件，作用是保存 store 给子组件中的 connect 使用</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;Provider store=&#123;<span class="keyword">this</span>.props.store&#125;&gt;</span><br><span class="line">  &lt;h1&gt;hello world!&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Provider&gt;</span><br></pre></td></tr></table></figure>
<h3 id="Connect"><a href="#Connect" class="headerlink" title="Connect"></a>Connect</h3><p>Connect 把 State 和 dispatch 转换成 props 传递给子组件。</p>
<pre><code class="jsx">
</code></pre>
<h3 id="mapStateToProps"><a href="#mapStateToProps" class="headerlink" title="mapStateToProps"></a>mapStateToProps</h3><h3 id="mapDispatchToProps"><a href="#mapDispatchToProps" class="headerlink" title="mapDispatchToProps"></a>mapDispatchToProps</h3><h3 id="bindActionCreators"><a href="#bindActionCreators" class="headerlink" title="bindActionCreators"></a>bindActionCreators</h3>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>React</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title>超级简单的前端自动化构建</title>
    <url>/blog/2017/12/26/%E8%B6%85%E7%BA%A7%E7%AE%80%E5%8D%95%E7%9A%84%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="为什么要自动化"><a href="#为什么要自动化" class="headerlink" title="为什么要自动化"></a>为什么要自动化</h2><blockquote>
<p>你好，切图仔！<br></p>
</blockquote>
<p>现在的前端早已不是简单的静态页面开发，一些大型的 Web App 动辄几千行甚至上万行代码，所以如何构建本地开发环境尤为重要。本篇文章将以 gulp 为例，从编译、文件合并、文件压缩、单元测试等几个角度从零开始搭建一个简单的前端开发环境。</p>
<a id="more"></a>
<p><strong>Github 地址：<a href="https://github.com/donley828/gulp-demo" target="_blank">gulp-demo</a></strong></p>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>抛开项目类型，一个项目 Js 文件和目录结构应该有以下几个特点：</p>
<ul>
<li>一个文件只包含一个对象</li>
<li>相关的文件用目录分组</li>
<li>保持第三方代码的独立</li>
<li>确定创建文位置</li>
<li>保持测试代码的完整性</li>
</ul>
<p>以 jQuery 项目的目录结构为例<br><br><img src="/blog/images/jq.png" alt><br><br>build：用来放置最终构建后的文件（不应该被提交）<br>src：用来放置所有的源文件，包括用例进行文件分组的子目录<br>test：用来放置测试文件，包含一些同源代码目录对应的子目录或文件<br>external：用来存放一些外部拓展文件<br>Gruntfile.js：grunt 配置文件，用来配置或定义任务并加载 Grunt 插件<br>package.json：描述了一个 NPM 包的所有相关信息<br>.eslintrc：Eslint 配置文件</p>
<h2 id="从零开始"><a href="#从零开始" class="headerlink" title="从零开始"></a>从零开始</h2><h3 id="创建一个-Gulp-项目"><a href="#创建一个-Gulp-项目" class="headerlink" title="创建一个 Gulp 项目"></a>创建一个 Gulp 项目</h3><p>假设你已经安装了 Node，通过<code>npm init</code>初始化一个<code>package.json</code>文件 ，然后新建一个<code>gulpfile.js</code>文件，执行<code>npm install grunt --save-dev</code>安装 Gulp。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//gulpfile.js</span></span><br><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'default'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>运行 gulp</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gulp</span><br></pre></td></tr></table></figure>
<p>使用命令<code>gulp</code>会使默认是的名为 default 的任务（task）将会被运行，此示例未做任何事情。</p>
<h3 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h3><p>在团队开发中，编程风格（style guideline）和编码规范（code convention）的一致性是及其重要的，即时是缩进统一，也会给后期维护节省大量的时间成本。所以使用像 ESLint 这样的工具是很有必要的，不仅可以找出代码中潜在的错误，而且能针对你的代码给出编程风格上的警告。</p>
<p>安装 gulp-eslint</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm i --save-dev gulp-eslint</span><br></pre></td></tr></table></figure>
<p>给<code>gulpfile</code>添加 lint 任务</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">'lint'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src([<span class="string">'**/*.js'</span>, <span class="string">'!node_modules/**'</span>])</span><br><span class="line">    .pipe(eslint())</span><br><span class="line">    .pipe(eslint.formatEach(<span class="string">'compact'</span>, process.stderr));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="使用-gulp-concat-和-gulp-uglify-合并压缩"><a href="#使用-gulp-concat-和-gulp-uglify-合并压缩" class="headerlink" title="使用 gulp-concat 和 gulp-uglify 合并压缩"></a>使用 gulp-concat 和 gulp-uglify 合并压缩</h3><p>如果恰当的组织 javaScript 文件，那么每个文件就只包含一个对象，但是会带来一个问题，就是会增加网络请求数。所以应该将文件合并，合并之后进行压缩工作，尽可能的缩小文件大小。</p>
<p>安装 gulp-concat 和 gulp-uglify</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm i --save-dev gulp-concat gulp-uglify</span><br></pre></td></tr></table></figure>
<p>添加 javaScript 任务到<code>gulpfile.js</code>中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">'javascript'</span>, [<span class="string">'lint'</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src(<span class="string">'src/**/*.js'</span>)</span><br><span class="line">    .pipe(sourcemaps.init())</span><br><span class="line">    .pipe(concat(<span class="string">'all.js'</span>))</span><br><span class="line">    .pipe(uglify())</span><br><span class="line">    .pipe(sourcemaps.write())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'dist'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>然后修改<code>gulp.task(..)</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">'default'</span>, [<span class="string">'lint'</span>, <span class="string">'javascript'</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>合并和压缩任务添加结束之后我们可以在<code>src</code>文件夹里尝试一下,添加<code>add.js</code>和<code>multiply.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//add.js</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = add;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//multiply.js</span></span><br><span class="line"><span class="keyword">var</span> multiply = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = multiply;</span><br></pre></td></tr></table></figure>
<p>执行<code>gulp</code>,控制台会输出如下内容，项目目录会生成<code>dist</code>文件夹，里面存放压缩并合并后的<code>all.js</code>文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gulp</span><br><span class="line">[21:23:44] Using gulpfile gulpfile.js</span><br><span class="line">[21:23:44] Starting <span class="string">'lint'</span>...</span><br><span class="line">1 problem[21:23:45] Finished <span class="string">'lint'</span> after 657 ms</span><br><span class="line">[21:23:45] Starting <span class="string">'javascript'</span>...</span><br><span class="line">[21:23:45] Finished <span class="string">'javascript'</span> after 57 ms</span><br><span class="line">[21:23:45] Starting <span class="string">'default'</span>...</span><br><span class="line">[21:23:45] Finished <span class="string">'default'</span> after 29 μs</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//all.js</span></span><br><span class="line"><span class="keyword">var</span> add=<span class="function"><span class="keyword">function</span>(<span class="params">r,t</span>)</span>&#123;<span class="keyword">return</span> r+t&#125;;<span class="built_in">module</span>.exports=add;<span class="keyword">var</span> multiply=<span class="function"><span class="keyword">function</span>(<span class="params">r,t</span>)</span>&#123;<span class="keyword">return</span> r*t&#125;;<span class="built_in">module</span>.exports=multiply;</span><br><span class="line"><span class="comment">//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFkZC5qcyIsIm11bHRpcGx5LmpzIl0sIm5hbWVzIjpbImFkZCIsIngiLCJ5IiwibW9kdWxlIiwiZXhwb3J0cyIsIm11bHRpcGx5Il0sIm1hcHBpbmdzIjoiQUFBQSxJQUFBQSxJQUFBLFNBQUFDLEVBQUFDLEdBQ0EsT0FBQUQsRUFBQUMsR0FHQUMsT0FBQUMsUUFBQUosSUNKQSxJQUFBSyxTQUFBLFNBQUFKLEVBQUFDLEdBQ0EsT0FBQUQsRUFBQUMsR0FHQUMsT0FBQUMsUUFBQUMiLCJmaWxlIjoiYWxsLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGFkZCA9IGZ1bmN0aW9uKHgsIHkpIHtcclxuXHRyZXR1cm4geCArIHk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGFkZDtcclxuIiwidmFyIG11bHRpcGx5ID0gZnVuY3Rpb24oeCwgeSkge1xyXG5cdHJldHVybiB4ICogeTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gbXVsdGlwbHk7XHJcbiJdfQ==</span></span><br></pre></td></tr></table></figure>
<h3 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h3><p>安装 gulp-mocha 和 chai ，前者是一款测试框架，就是运行测试的工具，在浏览器和 Node 环境都可以使用，添加测试，从而保证代码的质量。chai 是一款 js 断言库，就是判断源码的实际执行结果与预期结果是否一致。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm i --save-dev gulp-mocha chai</span><br></pre></td></tr></table></figure>
<p>为<code>add.js</code>和<code>multiply.js</code>添加测试脚本<code>add.test.js</code>和<code>multiply.test.js</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//add.test.js</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="built_in">require</span>(<span class="string">'../src/add.js'</span>);</span><br><span class="line"><span class="keyword">var</span> expect = <span class="built_in">require</span>(<span class="string">'chai'</span>).expect;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'加法函数的测试'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  it(<span class="string">'1 加 1 应该等于 2'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    expect(add(<span class="number">1</span>, <span class="number">1</span>)).to.be.equal(<span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//multiply.test.js</span></span><br><span class="line"><span class="keyword">var</span> multiply = <span class="built_in">require</span>(<span class="string">'../src/multiply.js'</span>);</span><br><span class="line"><span class="keyword">var</span> expect = <span class="built_in">require</span>(<span class="string">'chai'</span>).expect;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'乘法函数的测试'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  it(<span class="string">'2 乘 2 应该等于 4'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    expect(multiply(<span class="number">2</span>, <span class="number">2</span>)).to.be.equal(<span class="number">4</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>describe</code>块称为”测试套件”（test suite），表示一组相关的测试。它是一个函数，第一个参数是测试套件的名称（”加法函数的测试”），第二个参数是一个实际执行的函数。<br><code>it</code>块称为”测试用例”（test case），表示一个单独的测试，是测试的最小单位。它也是一个函数，第一个参数是测试用例的名称（”1 加 1 应该等于 2”），第二个参数是一个实际执行的函数。</p>
<p>添加 gulp 任务</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">'test'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.src(<span class="string">'test/*.test.js'</span>, &#123; <span class="attr">read</span>: <span class="literal">false</span> &#125;).pipe(</span><br><span class="line">    mocha(&#123;</span><br><span class="line">      reporter: <span class="string">'spec'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>执行<code>gulp test</code>，如下输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[21:37:31] Starting <span class="string">'test'</span>...</span><br><span class="line">  加法函数的测试</span><br><span class="line">    √ 1 加 1 应该等于 2</span><br><span class="line">  乘法函数的测试</span><br><span class="line">    √ 2 乘 2 应该等于 4</span><br><span class="line">  2 passing (6ms)</span><br><span class="line">[21:37:32] Finished <span class="string">'test'</span> after 502 ms</span><br></pre></td></tr></table></figure>
<p>表示测试通过</p>
<h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><p>Webpack 是一款优秀的前端模块打包器，它可以找到 JavaScript 模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript 等），并将其转换和打包为合适的格式供浏览器使用。与 Gulp/Grunt 相比，Gulp/Grunt 是一种能够优化前端开发流程的工具，Webpack 是一种模块化的解决方案，同时 Webpack 在很多场景下可以替代 Gulp/Grunt 这类工具。所以 Webpack 是非常值得学习的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章是在读完 <a href="https://book.douban.com/subject/21792530/" target="_blank">《编写可维护的 JavaScript》</a> 这本书之后，做的总结性实践类文章。总之，如今的前端工程化完善，本文的例子只是很简单的内容，<code>gulp</code>的具体使用，复杂应用的测试等内容还有待深入。</p>
<p><strong>Github 地址：<a href="https://github.com/donley828/gulp-demo" target="_blank">gulp-demo</a></strong></p>
<blockquote>
<p>Reference:<br><a href="https://www.gulpjs.com.cn/" target="_blank">Gulp 中文网</a><br><a href="http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html" target="_blank">测试框架 Mocha 实例教程</a></p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>模块化</tag>
        <tag>自动化</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript模块化</title>
    <url>/blog/2017/10/16/Javascript%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="Javascript-模块化"><a href="#Javascript-模块化" class="headerlink" title="Javascript 模块化"></a>Javascript 模块化</h1><p>当今的网站已经逐渐变成的 Web 应用，网页引入的 Javascript 文件也越来越多，越来越复杂。网页就像桌面程序一样，需要一系列软件工程的方法，来管理网页的业务逻辑。所以 Javascript 模块化就成为了一种迫切的需求。但是 Javascript 又没有像 JAVA 语言中的类特性，所以如何实现模块化就成了一个难题。令人欣慰的是，经过 Javascript 的一系列努力，Javascript 模块化已经趋于成熟，本文将会总结模块化的几种方法以及模块化的规范。</p>
<a id="more"></a>
<h2 id="如何实现模块化"><a href="#如何实现模块化" class="headerlink" title="如何实现模块化"></a>如何实现模块化</h2><h3 id="原始写法"><a href="#原始写法" class="headerlink" title="原始写法"></a>原始写法</h3><p>模块就是实现某一功能的一个程序块。比如下面这段代码就组成了一个模块</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//dosomething</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//dosomething</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序块中的函数 a() 和 b()，组成了一个模块。但是这种做法暴漏出了一个明显的缺点，“污染”了全局变量，在多人开发过程中，无法保证其他人与你定义的变量名不会发生冲突，而且模块成员之间看不出直接关系。</p>
<h3 id="对象写法"><a href="#对象写法" class="headerlink" title="对象写法"></a>对象写法</h3><p>为了解决这个问题，我们就可以把模块写成对象的形式，模块成员作为对象的属性存在。例如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m1 = &#123;</span><br><span class="line">  _count: <span class="number">0</span>,</span><br><span class="line">  a: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//dosomething</span></span><br><span class="line">  &#125;,</span><br><span class="line">  b: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//dosomething</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这种写法又存在一种问题就是，模块的成员被“暴露”在外部可以被直接修改，不能以“私有变量”的形式存在。</p>
<h3 id="立即调用函数"><a href="#立即调用函数" class="headerlink" title="立即调用函数"></a>立即调用函数</h3><p>严格来讲，Javascript 中没有私有变量的概念，所有的对象属性都是公开的。不过，任何在函数中定义的变量，都可以认为是私有变量，因为你不能在函数的外部访问它们。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m1 = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//dosomething</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//dosomething</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    a: a,</span><br><span class="line">    b: b</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>这样书写之后，代码外部无法读取内部的_count 变量，只能使用模块提供的 a 和 b 特权函数。这就是 Javascript 模块的基本写法。</p>
<h3 id="放大模式"><a href="#放大模式" class="headerlink" title="放大模式"></a>放大模式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m1 = (<span class="function"><span class="keyword">function</span>(<span class="params">mod</span>) </span>&#123;</span><br><span class="line">  mod.c = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//dosomething</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)(m1);</span><br></pre></td></tr></table></figure>
<p>上面的代码为 m1 模块添加了一个新方法 c()，然后返回新的 m1 模块。</p>
<h3 id="宽放大模式"><a href="#宽放大模式" class="headerlink" title="宽放大模式"></a>宽放大模式</h3><p>浏览器环境中，模块的每个部分可能是从网上获取的，有时无法知道哪个部分先加载。如果采用上一节的写法，第一个执行的部分有可能加载一个不存在的空对象，这时就要采用“宽放大模式”。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m1 = (<span class="function"><span class="keyword">function</span>(<span class="params">mod</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//dosomething</span></span><br><span class="line">  <span class="keyword">return</span> mod;</span><br><span class="line">&#125;)(<span class="built_in">window</span>.m1 || &#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>宽放大模式就是允许立即调用函数可以是空对象。</p>
<h3 id="全局变量注入"><a href="#全局变量注入" class="headerlink" title="全局变量注入"></a>全局变量注入</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m1 = (<span class="function"><span class="keyword">function</span>(<span class="params">mod</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//dosomething</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>.model);</span><br></pre></td></tr></table></figure>
<p>这个时候的 mod 其实就是全局的 model</p>
<h2 id="模块化规范"><a href="#模块化规范" class="headerlink" title="模块化规范"></a>模块化规范</h2><h3 id="CommonJs"><a href="#CommonJs" class="headerlink" title="CommonJs"></a>CommonJs</h3><p>官方是这样解释 CommonJS</p>
<blockquote>
<p>The CommonJS API will fill that gap by defining APIs that handle many common application needs, ultimately providing a standard library as rich as those of Python, Ruby and Java.</p>
</blockquote>
<p>它提供了一个类似于 Ruby 和 Java 的标准库，有了这个，我们就可以使用 CommonJS APIs 构建能够运行在不同的主机环境中的应用程序。比如，NodeJS 的模块系统就是参照 CommonJS 规范的实现，Webpack 也是以 CommonJS 新式来书写的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'math'</span>);</span><br><span class="line">math.add(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">//5</span></span><br></pre></td></tr></table></figure>
<p>这行代码就是在程序中引入了一个数学模块</p>
<h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h3><p>在 CommonJS 出现以后，服务端的模块概念已经形成，自然而然客户端也需要模块化。如果两者能够兼容，一个模块能够同时在服务端和客户端运行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'math'</span>);</span><br><span class="line">math.add(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">//5</span></span><br></pre></td></tr></table></figure>
<p>还是这行代码，如果在浏览器中运行，它会出现一个及其严重的问题，就是 math.add(2, 3) 这行代码必须等待 math 模块加载结束之后才能运行。如果加载时间过长，应用就会出现明显的卡顿。<br><br>因此浏览器端的模块加载就应该采用异步(Async)的形式，这就是 AMD 规范诞生的原因。require.js 库实现了 AMD 规范。之后会进一步研究这个规范。</p>
<h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>玉伯写的 sea.js 就是遵循他提出的 CMD 规范，与 AMD 类似。</p>
<blockquote>
<p>Reference: <a href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html" target="_blank">Ruanyf</a></p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>模块化</tag>
      </tags>
  </entry>
</search>
